//! Operations for installing core library.

use walkdir::WalkDir;
use std::io::{Cursor, Read, Write};
use anyhow::Context;

use crate::prelude::*;

pub async fn archive<P: AsRef<Path>>(lib_path: P) -> Result<zip::ZipArchive<Cursor<Vec<u8>>>> {
    let lib_path = lib_path.as_ref();
    let lib_core_path = lib_path.join("core");

    println!("archiving {}", lib_core_path.display());

    // check is core
    if !(lib_core_path.exists()) {
        return Err(anyhow!("archive error: core path {} doesn't exist", lib_core_path.display()));
    }
    let moon_mod_json_path = lib_core_path.join("moon.mod.json");
    if !(moon_mod_json_path.exists()) {
        return Err(anyhow!("archive error: core json {} is missing", moon_mod_json_path.display()));
    }

    // create archive
    let mut zip = zip::ZipWriter::new(Cursor::new(vec![]));
    zip.set_comment("backup of MoonBit core, generated by MultiMoon");

    let ignore_target_path = PathBuf::from("core").join("target");
    let mut archived_count = 0;
    let walk = WalkDir::new(lib_core_path);
    for entry in walk {
        let entry = entry?;
        let path_abs = entry.path();
        let path_rel = path_abs.strip_prefix(lib_path)?;
        let path_rel_str = path_rel.to_str().map(str::to_owned)
            .with_context(|| format!("path {} is not supported", path_rel.display()))?;

        // create options (use unix permissions of original file/dir)
        let options = {
            let o = zip::write::SimpleFileOptions::default()
                .compression_method(zip::CompressionMethod::DEFLATE)
                .compression_level(Some(6));
            let o = {
                #[cfg(unix)]
                {
                    use std::os::unix::fs::PermissionsExt;
                    let metadata = std::fs::metadata(path_abs)?;
                    let mode = metadata.permissions().mode();
                    o.unix_permissions(mode)
                }
                #[cfg(not(unix))]
                { o }
            };
            o
        };

        // ignore any target file
        if path_rel.starts_with(&ignore_target_path) {
            continue;
        }

        let (add_file, add_dir) = (path_abs.is_file(), (path_abs.is_dir() && (!path_rel.as_os_str().is_empty())));

        if add_file || add_dir {
            if global().verbose || archived_count < 5 {
                println!("archiving {}", path_rel.display());
            } else if (!global().verbose) && archived_count == 5 {
                println!(" (further archived files omitted)");
            }
            archived_count += 1;
        }

        if add_file {
            zip.start_file(path_rel_str, options)?;
            let mut file_buf = Vec::new();
            let mut file = std::fs::File::open(path_abs)?;
            file.read_to_end(&mut file_buf)?;
            zip.write_all(&file_buf)?;
        } else if add_dir {
            zip.add_directory(path_rel_str, options)?;
        }
    }

    let zip_buf: zip::ZipArchive<Cursor<Vec<u8>>> = zip.finish_into_readable()?;
    Ok(zip_buf)
}

